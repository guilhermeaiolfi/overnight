<?php

namespace ON\Config;


use Brick\VarExporter\ExportException;
use Brick\VarExporter\VarExporter;
use Closure;
use Exception;
use Generator;
use Laminas\ConfigAggregator\ArrayProvider;
use Laminas\ConfigAggregator\ConfigCannotBeCachedException;
use Laminas\ConfigAggregator\InvalidConfigProcessorException;
use Laminas\ConfigAggregator\InvalidConfigProviderException;
use Laminas\Stdlib\ArrayUtils\MergeRemoveKey;
use Laminas\Stdlib\ArrayUtils\MergeReplaceKeyInterface;
use ON\Config\Provider\ClassProvider;
use ON\Config\Provider\ResourceProviderInterface;
use Webimpress\SafeWriter\Exception\ExceptionInterface as FileWriterException;
use Webimpress\SafeWriter\FileWriter;

use Symfony\Component\Config\ConfigCache;

use function array_key_exists;
use function class_exists;
use function date;
use function file_exists;
use function gettype;
use function is_array;
use function is_callable;
use function is_int;
use function is_object;
use function is_string;
use function sprintf;

/**
 * Aggregate configuration generated by configuration providers.
 *
 * @psalm-type ProviderCallable = callable(): mixed
 * @psalm-type ProviderIterable = iterable<int, ProviderCallable|class-string>
 * @psalm-type PostProcessorCallable = callable(array): array
 * @psalm-type PreProcessorCallable = callable(ProviderIterable): ProviderIterable
 */
class ConfigBuilder
{
    public const ENABLE_CACHE = 'config_cache_enabled';

    public const CACHE_FILEMODE = 'config_cache_filemode';

    /**
     * @todo Make this constant private in version 2.0.0
     */
    public const CACHE_TEMPLATE = <<<'EOT'
<?php

/**
 * This configuration cache file was generated by %s
 * at %s
 */
%s

EOT;

    private array $resources;

    private array $config;

    private string $from = "memory";

    private string $phase = "boot";

    private ConfigCache $configCache;

    /**
     * @param ProviderIterable $providers Array or \Iterator of providers. These may be
     *     callables, or string values representing classes that act as providers. If the latter, they must be
     *     instantiable without constructor arguments.
     * @param null|non-empty-string $cachedConfigFile Configuration cache file; config is loaded from this file if
     *     present, and written to it if not. null disables caching.
     * @param list<PostProcessorCallable|class-string> $postProcessors Array of post-processors. These may be callables,
     *     or string values representing classes that act as post-processors. If the latter, they must be instantiable
     *     without constructor arguments.
     * @param list<PreProcessorCallable|class-string> $preProcessors Array of pre-processors. These may be callables, or
     *     string values representing classes that act as pre-processors. If the latter, they must be instantiable
     *     without constructor arguments.
     */
    public function __construct(
        protected array $providers = [],
        protected $cachedConfigFile = null,
        protected array $postProcessors = [],
        protected array $preProcessors = [],
        protected bool $debug = true
    ) {
        $this->configCache = new ConfigCache($cachedConfigFile, $debug);

        if ($this->configCache->isFresh()) {
            $this->loadConfigFromCache();
        } else {
            $this->compile();
        }
    }

    public function shouldLoad()
    {
        return $this->phase == "boot" && $this->from != "cache";
    }

    public function compile() {
        $this->config = [];
        $providers    = $this->preProcessProviders($this->preProcessors, $this->providers);
        $this->config = $this->loadConfigFromProviders($providers, [], false, false, false);
        $this->config = $this->postProcessConfig($this->postProcessors, $this->config);
    }

    /**
     * @return array
     */
    public function getMergedConfig()
    {
        return $this->config;
    }

    /**
     * Resolve a provider.
     *
     * If the provider is a string class name, instantiates that class and
     * tests if it is callable, returning it if true.
     *
     * If the provider is a callable, returns it verbatim.
     *
     * Raises an exception for any other condition.
     *
     * @param ProviderCallable|class-string $provider
     * @return ProviderCallable
     * @throws InvalidConfigProviderException
     */
    private function resolveProvider(string|callable $provider): callable
    {
        if (is_string($provider)) {
            if (! class_exists($provider)) {
                throw InvalidConfigProviderException::fromNamedProvider($provider);
            }
            $provider = new ClassProvider($provider);
        } else if (is_object($provider) && !$provider instanceof ResourceProviderInterface) {
            if (!class_exists(get_class($provider))) {
                throw InvalidConfigProviderException::fromNamedProvider(get_class($provider));
            }
            $provider = new ClassProvider($provider);
        }

        if (! is_callable($provider)) {
            $type = $this->detectVariableType($provider);
            throw InvalidConfigProviderException::fromUnsupportedType($type);
        }

        if (is_object($provider) && $provider instanceof ResourceProviderInterface) {
            $this->resources[] = $provider->getResource();
        }
        // phpcs:ignore SlevomatCodingStandard.Commenting.InlineDocCommentDeclaration.MissingVariable
        /** @var ProviderCallable $provider */
        return $provider;
    }

    /**
     * Resolve a processor.
     *
     * If the processor is a string class name, instantiates that class and
     * tests if it is callable, returning it if true.
     *
     * If the processor is a callable, returns it verbatim.
     *
     * Raises an exception for any other condition.
     *
     * @param PostProcessorCallable|PreProcessorCallable|class-string $processor
     * @return PostProcessorCallable|PreProcessorCallable
     * @throws InvalidConfigProcessorException
     */
    private function resolveProcessor(string|callable $processor): callable
    {
        if (is_string($processor)) {
            if (! class_exists($processor)) {
                throw InvalidConfigProcessorException::fromNamedProcessor($processor);
            }
            $processor = new $processor();
        }

        if (! is_callable($processor)) {
            $type = $this->detectVariableType($processor);
            throw InvalidConfigProcessorException::fromUnsupportedType($type);
        }

        // phpcs:ignore SlevomatCodingStandard.Commenting.InlineDocCommentDeclaration.MissingVariable
        /** @var PostProcessorCallable|PreProcessorCallable $processor */
        return $processor;
    }

    public function getResources(): array
    {
       return $this->resources;
    }
    /**
     * Perform a recursive merge of two multidimensional arrays.
     *
     * @codingStandardsIgnoreStart
     * Copied from https://github.com/laminas/laminas-stdlib/blob/980ce463c29c1a66c33e0eb67961bba895d0e19e/src/ArrayUtils.php#L269
     * @codingStandardsIgnoreEnd
     *
     * @param array $a
     * @param array $b
     *
     * @return $a
     */
    private function mergeArray(array $a, array $b): array
    {
        foreach ($b as $key => $value) {
            if ($value instanceof MergeReplaceKeyInterface) {
                $a[$key] = $value->getData();
            } elseif (isset($a[$key]) || array_key_exists($key, $a)) {
                if ($value instanceof MergeRemoveKey) {
                    unset($a[$key]);
                } elseif (is_int($key)) {
                    $a[] = $value;
                } elseif (is_array($value) && is_array($a[$key])) {
                    $a[$key] = $this->mergeArray($a[$key], $value);
                } else {
                    $a[$key] = $value;
                }
            } else {
                if (! $value instanceof MergeRemoveKey) {
                    $a[$key] = $value;
                }
            }
        }
        return $a;
    }

    public function getConfigFromProvider($provider): array {
        
        $provider = $this->resolveProvider($provider);
        $config = $provider();
        if (! $config instanceof Generator) {
            return $config;
        }
        $mergedConfig = [];
        foreach ($config as $cfg) {
            $mergedConfig = $this->mergeArray($mergedConfig, $cfg);
        }
        return $mergedConfig;
    }

    public function loadConfigFromProvider($provider, $mergedConfig = null, bool $preProcess = true, bool $postProcess = true, bool $saveProvider = true) {
        if (null === $mergedConfig) {
            $mergedConfig = $this->config;
        }
        if ($saveProvider) {
            $this->providers[] = $provider;
        }
        if ($preProcess) {
            $provider = $this->preProcessProvider($this->preProcessors, $provider, $this->providers);
        }

        $chunk = $this->getConfigFromProvider($provider);

        if ($postProcess) {
            $chunk = $this->postProcessConfigChunk($this->postProcessors, $mergedConfig, $chunk);
        }

        $mergedConfig = $this->mergeArray($mergedConfig, $chunk);

        if ($saveProvider) {
            $this->config = $mergedConfig;
        }
        return $mergedConfig;
    }

    /**
     * Iterate providers, merging config from each with the previous.
     *
     * @param ProviderIterable $providers
     */
    protected function loadConfigFromProviders(iterable $providers, $mergedConfig = [], bool $preProcess, bool $postProcess, bool $saveProvider): array
    {
        foreach ($providers as $provider) {
            $mergedConfig = $this->loadConfigFromProvider($provider, $mergedConfig, $preProcess, $postProcess, $saveProvider);
        }
        return $mergedConfig;
    }

    /**
     * Attempt to load the configuration from a cache file.
     *
     * @param null|non-empty-string $cachedConfigFile
     */
    public function loadConfigFromCache(): bool
    {
        if (null === $this->cachedConfigFile) {
            return false;
        }
        
        if (! file_exists($this->cachedConfigFile)) {
            return false;
        }
        
        $this->config = require $this->cachedConfigFile;
        $this->from = "cache";
        return true;
    }



    /**
     * @param list<PreProcessorCallable|class-string> $processors
     * @param ProviderIterable $providers
     * @return ProviderIterable
     */
    protected function preProcessProviders(array $processors, iterable $providers): iterable
    {
        foreach ($processors as $processor) {
            /** @var PreProcessorCallable $processorCallable */
            $processorCallable = $this->resolveProcessor($processor);
            $providers         = $processorCallable($providers, null);
        }

        return $providers;
    }

    protected function preProcessProvider(array $processors, $provider, $providers) {
        foreach ($processors as $processor) {
            /** @var PreProcessorCallable $processorCallable */
            $processorCallable = $this->resolveProcessor($processor);
            $provider         = $processorCallable($provider, $providers);
        }

        return $provider;
    } 

    /**
     * @param list<PostProcessorCallable|class-string> $processors
     */
    public function postProcessConfig(array $processors, array $config): array
    {
        foreach ($processors as $processor) {
            /** @var PostProcessorCallable $processorCallable */
            $processorCallable = $this->resolveProcessor($processor);
            $config            = $processorCallable($config);
        }

        return $config;
    }

    /**
     * @param list<PostProcessorCallable|class-string> $processors
     */
    public function postProcessConfigChunk(array $processors, array $current, array $chunk): array
    {
        foreach ($processors as $processor) {
            /** @var PostProcessorCallable $processorCallable */
            $processorCallable = $this->resolveProcessor($processor);
            $chunk            = $processorCallable($current, $chunk);
        }

        return $chunk;
    }

    private function detectVariableType(object|callable $variable): string
    {
        if ($variable instanceof Closure) {
            return 'Closure';
        }

        if (is_object($variable)) {
            return $variable::class;
        }

        return is_string($variable) ? $variable : gettype($variable);
    }

    public function registerToLoad($obj)
    {
        $this->providers[] = $obj;
    }

    public function save(bool $force = false) {
        if ($this->from == "cache") {
            $this->phase = "runtime";
            return;
        }
        if (!$this->config || !$this->resources)
        {
            $this->compile();
        }
        $this->writeCache($this->config, $this->resources, $force);
        $this->phase = "runtime";
    }
     /**
     * Attempt to cache discovered configuration.
     *
     * @param null|non-empty-string $cachedConfigFile
     * @throws ConfigCannotBeCachedException
     */
    public function writeCache(array $config, array $resources, bool $force = false): void
    {
        try {
            $contents = sprintf(
                self::CACHE_TEMPLATE,
                static::class,
                date('c'),
                VarExporter::export($config, VarExporter::ADD_RETURN | VarExporter::CLOSURE_SNAPSHOT_USES)
            );
        } catch (ExportException $e) {
            throw ConfigCannotBeCachedException::fromExporterException($e);
        }
        $this->configCache->write(
            $contents,
            $resources
        );
    }
}
